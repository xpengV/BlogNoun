---
title: 单例模式
date: 2017-06-03 09:21:20
tags:
- 设计模式
---

单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
Singleton类，定义一个getInstance静态方法，允许客户访问它的唯一实例。

## 单例模式 

```java
package com.xiaopeng.singleton;

public class Singleton {

    private static Singleton instance;

    private  Singleton()
    { }

    public static Singleton getInstance()
    {
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}

```
- 构造方法私有，防止外界利用构造方法进行实例化
- getInstance是外界唯一能够访问的入口
- 若实例存在，那么直接返回。全局只有一个对象

```java
Singleton s1 = Singleton.getInstance();
Singleton s2 = Singleton.getInstance();

System.out.println(s1 == s2);  //true：表示两次实例化结果一样，是单例的
```

## 多线程下的单例模式
应用程序中存在多个线程同时来创建Singleton对象的实例时，上述代码往往会出现问题。假设线程a开始要执行13行代码（注意：是还没有执行），此时线程b获取了cpu的执行权限。线程b判断instance还没有被创建过，那么线程b会实例化Singleton对象。当线程a获得cpu执行权时，继续执行
```java
instance = new Singleton();
```
那么系统中就会出现两个Singleton的实例。

我们可以使用同步代码块或则同步函数，来解决多线程的安全问题
```java
package com.xiaopeng.singleton;

public class Singleton {

    private static Singleton instance;

    private  Singleton()
    { }

    public synchronized static Singleton getInstance()
    {
        if(instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}

```
使用synchronized关键字修饰getInstance方法后，该函数在同一时间只能由一个线程调用，就会避免上述问题。

注：多线程条件下，因为添加了同步机制，效率会比单线程慢。可以做如下优化：
**先判断实例是否存在，不存在再进行加锁处理，否则直接返回。**
