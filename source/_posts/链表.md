---
title: 链表
date: 2018-03-09 22:52:11
tags:
- 数据结构
- 链表
---
前面已经说过[线性表](https://xpengv.github.io/2018/03/02/线性表/)类型的结构在进行插入和删除操作时要移动大量元素，导致时间复杂度高。

链表中，每一数据元素需要存储数据信息之外，还要存储它的后继元素的内存地址。
![链表结构](/img/LinkedList/链表-1.png)

<!-- more -->

### 头指针与头结点

头指针 | 头结点
---|---
头指针是指向链表第一个结点的指针；头指针具有标识作用；无论链表是否为空，头指针均不为空 | 头结点是为了链表操作方便而设立的，放在第一个元素之前；

**头指针是头结点的指针域部分**

### 单链表的存储结构
```cpp
type struct Node
{
    ElemType data;
    Struct Node *next;
} Node;

typedef struct Node *LinkList;

```

链表的结点由存放数据元素的数据域和存放后继结点的指针域组成
![链表结点描述](/img/LinkedList/链表-2.png)

## 单链表的创建
创建单链表的过程就是一个动态生成链表的过程。从“空表”的初始状态开始，依次建立各个结点，并逐个插入链表中。
**头插法建立单链表：**
1. 声明一个结点p和计数器变脸i
2. 初始化空链表L
3. 让L的的头结点的指针指向NULL，即建立一个带头结点的单链表
4. Loop:
	- 生成新结点赋值给p
	- 结点p的数据域赋值
	- 将p插入到头结点与前一个结点之间

```cpp
void create_linklist(LinkList *L,int n)
{
    LinkList p;
    int i;
    *L = (LinkList)malloc(sizeof(Node));
    
    (*L)->next = NULL; /* 建立一个带头结点的单链表 */

    for(i=0;i<n;i++)
    {
        p = (LinkList)malloc(sizeof(Node)); /* 生成新结点 */
        p->data = rand()%100 + 1; /* 随机数 */
        p->next = (*L)->next;  /* 新结点指向前一个结点 */
        (*L)->next = p;  /* 头结点指向p，这就是头插法 */
    }
}
```

**尾插法创建单链表：**
```cpp
void creata_list_tail(LinkList *L ,int n)
{
    LinkList p,r;
    int i;
    
    *L = (LinkList)malloc(sizeof(Node));

    r = *L;  /* r直线尾部的结点 */
    for(i=0;i<n;i++)
    {
        p = (LinkList)malloc(sizeof(Node));
        p->data = rand()%100 + 1;
        r->next = p; /* 将当前链表的终端结点的指针域指向新的结点 */
        r = p; /* 现在链表的尾节点的指针域应该是p的指针域 */
    }
    
    r->next = NULL; /* 链表创建完毕，尾结点指向NULL */
}

```

## 单链表的插入
通俗来讲，要向单链表中插入一个元素，那么
1. 新增结点的指针域指向后续结点
2. 新增结点上一个结点的指针域指向新增结点
就可以完成单链表的结点插入。

假设现在要向单链表L的第i个元素前插入新的数据元素e:

```cpp
Status list_insert(LinkList *L,int I,ElemType e)
{
    int j;
    LinkList p,s;
    
    p = *L;
    j = 1;
    while(p && j<i)  /* 寻找第i个结点 */
    {
        p = p->next;
        j++;
    }

    if(!p || j>i)
    {
        return ERROR; /* 下标I不存在 */
    }

    s = (LinkList)malloc(sizeof(Node));
    s->data = e;  /* 数据域赋值 */
    s->next = p->next; /* ①、新增结点s指向剩余链表 */
    p->next = s;  /* ②、p指向新增结点 */

    return OK;
}
```

若上述代码①和②互换位置，会导致剩余链表的地址丢失，链表数据丢失。

## 单链表的删除
与单链表的插入原理相同，需要完成以下几步：
1. 查找单链表中需要删除的元素，若没有则抛错
2. 将被删除结点的前一个结点的指针域指向被删除结点的后一个结点 * p->next = p->next->next *
3. 将删除结点的数据返回 *e = p->data

## 单链表结构与顺序存储结构的优缺点

1. 时间性能
	- 单链表查找慢O(n)；线性表快o(1)
	- 单链表插入和删除快o(1)；线性表慢O(n)
2. 空间性能
	- 单链表不需要分配存储空间大小，元素个数不受限制
	- 顺序存储结构需要预分配内存，而且存在硬件上限的限制

循环链表：将单链表中终端节点的指针域改为指向头结点，使得整个单链表形成一个环，这种首尾相接的单链表称为循环链表
