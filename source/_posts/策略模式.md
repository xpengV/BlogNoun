---
title: 策略模式
date: 2017-05-23 21:41:54
tags:
- 设计模式
---

在软件开发的过程中，实现某一个功能通常有多种算法或者策略，我们可以根据环境条件的不同来选取不同的算法或者策略来完成。
1. 提供多个方法供客户端调用
2. 将多种策略包装在一个方法中，通过if...else...来进行条件判断
这两种方法我们都将至称为硬编码（Hard Coding）。第一种方法若修改了算法，那么客户端也要进行相应的修改；第二种将导致程序庞大不易维护。

# 1、解决方法
将一个类经常改变或者可能改变的部分提取出来，作为接口，然后在类中维护一个接口的引用。这样就可以在具体的某个类中不同地实现接口的功能,从而实现不同的策略。

<!-- more -->

# 2、jdk中的使用
*java.io.File*的File[] listFiles(FileFilter filter)方法接收一个FileFilter参数，获得满足某种条件的文件。

```java
public File[] listFiles(FileFilter filter) {
        String ss[] = list();
        if (ss == null) return null;
        ArrayList<File> files = new ArrayList<>();
        for (String s : ss) {
            File f = new File(s, this);
            if ((filter == null) || filter.accept(f))   //策略模式体现
                files.add(f);
        }
        return files.toArray(new File[files.size()]);
    }

```
```java
public interface FileFilter {

    /**
     * Tests whether or not the specified abstract pathname should be
     * included in a pathname list.
     *
     * @param  pathname  The abstract pathname to be tested
     * @return  <code>true</code> if and only if <code>pathname</code>
     *          should be included
     */
    boolean accept(File pathname);
}
```

File[] listFiles方法传入FileFilter参数，接着调用了FileFilter的accept()方法。这里就使用了策略模式，客户端需要使用不同的策略只要在accept()方法中实现不同的逻辑即可。

## 2.1、列出目录下所有已.java结尾的文件
```java
package com.xiaopeng.strategy;

import org.junit.Test;

import java.io.File;
import java.io.FileFilter;

public class MyFileFilter {

    @Test
    public void test_E001()
    {
        File file = new File("./src/com/xiaopeng/strategy");
        File[] files = file.listFiles(new DiyFileFilter());  //传入该策略（只列出所有以.java结尾的文件）
        for(File f : files) {
            System.out.println(f.getName());
        }
    }

    class DiyFileFilter implements FileFilter{

        @Override
        public boolean accept(File file) {
            if(file.getName().endsWith(".java")){
                return true;
            }
            return false;
        }
    }

}

```

# 3、策略模式组成
- **抽象策略类（Strategy）:定义所有策略的公共接口，例如FileFilter.java**
- **环境类（Context）:维护一个抽象策略的引用，并调用策略中的具体算法**
- **具体策略类（ConcreteStrategy）:实现Strategy接口的具体实现类**

# 4、应用
假设某人从西安去伦敦，路上需要使用不同的交通工具。有摩拜单车、地铁、飞机。
1. 抽象策略类

```java
package com.xiaopeng.strategy;

public interface Strategy {

    /**
     * 乘坐交通工具
     */
    public void takeTransportation();
}

```

2. 具体抽象类

```java
package com.xiaopeng.strategy;

public class BicycleStrategy implements Strategy{

    @Override
    public void takeTransportation() {
        System.out.println("骑单车去地铁站");
    }
}

```
```java
package com.xiaopeng.strategy;

public class SubwayStrategy implements Strategy{

    @Override
    public void takeTransportation() {
        System.out.println("坐地铁去机场");
    }
}

```
```java
package com.xiaopeng.strategy;

public class AirplaneStrategy implements Strategy{

    @Override
    public void takeTransportation() {
        System.out.println("坐飞机去伦敦");
    }
}

```

3. 环境类

```java
package com.xiaopeng.strategy;

public class Context {

    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    public void takeTransportation(){
        this.strategy.takeTransportation();  //调用策略算法
    }
}

```

4. 客户端调用

```java
package com.xiaopeng.strategy;

import org.junit.Test;

public class App {

    @Test
    public void test_E001(){
        Context context;

        System.out.println("去地铁站.....");
        context = new Context(new BicycleIStrategy());  //策略1
        context.takeTransportation();

        System.out.println("去机场.....");
        context = new Context(new SubwayIStrategy());   //策略2
        context.takeTransportation();

        System.out.println("去伦敦.....");
        context = new Context(new AirplaneIStrategy());  //策略3
        context.takeTransportation();
    }
}

```

5. 
```java
去地铁站.....
骑单车去地铁站
去机场.....
坐地铁去机场
去伦敦.....
坐飞机去伦敦
```

# 5、策略模式类图
![策略模式类图](/img/设计模式/策略模式/Strategy.png)
# 6、应用场景及优缺点
“策略”提供了一种用多个行为中的一个行为来配置一个类的方法。即一个系统需要动态地在几种算法中选择一种。当一个应用程序需要实现一种特定的服务或者功能，而且该程序有多种实现方式时使用。
一个类定义了多种行为 , 并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移入它们各自的Strategy类中以代替这些条件语句。
- 优点
1、可以动态的改变对象的行为
- 缺点
1、客户端必须知道所有的策略类，并自行决定使用哪一个策略类
2、策略模式将产生很多具体策略类













