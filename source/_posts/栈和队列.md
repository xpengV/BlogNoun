---
title: 栈和队列
date: 2018-03-10 9:50:35
tags:
- 数据结构
---
**栈（stack）：是限定仅在表尾进行插入和删除操作的线性表。** 把允许插入和删除的一端称为栈顶（top），不含任何数据元素的栈称为空栈。栈是一种后进先出（LIFO）的线性表。

## 栈的结构定义
```cpp
typedef int SElemType;
typedef struct
{
    SElemType data[MAXSIZE];
    int top;  /* 指向栈顶元素 */
} SqStack;
```

<!-- more -->

## 压栈操作
```cpp
Status push(SqStack *S,SElemType e)
{
    if(S->top == MAXSIZE - 1) /* 栈已经满 */
    {
	return ERROR;
    }
    
    S->top ++;   /* 栈顶向上移动一位 */
    S->data[S->top] = e;  /* 新元素赋值 */
}
```

## 弹栈操作
```cpp
Status pop(SqStack *S,SElemType *e)
{
    if(S->top == -1)
    {
	return ERROR;
    }
    
    *e = S->data[S->top];
    S->top--;
    return OK;
}

```
压栈和弹栈的时间复杂度均为O(1)

## 栈的应用-逆波兰表达式
逆波兰表达式的使用规则：从左至右遍历表达式的每个数字和字符，遇到数字就进栈，遇到符号就将栈顶的两个元素出栈，并进行运算，将运算结果压栈，直到获得最终的结果。

假设我们直到如下表达式：
```
9 3 1 - 3 * + 10 2 / +
```
它对应的四则运算表达式为：
```
9 + ( 3 - 1 ) * 3 + 10 / 2
```

我们需要明确以下算法，然后进行程序设计：
1. 从左至右遍历
2. 遇到数字则进栈
3. 遇到运算符则将栈顶两元素出栈，运算后将运算结果进栈
4. 获取最终运算结果

```java
package com.xiaopeng.npl;

import java.util.Stack;

public class NplCalc {

    private static Object[] data = {9, 3, 1, "-", 3, "*", "+", 10, 2, "/", "+"};
    private static Stack<Object> stack = new Stack<>();

    public static void main(String[] args) {

        int p, q, res = 0;

        for (int i = 0; i < data.length; i++) {
            //1. 遇到数字则进栈
            if (data[i] instanceof Number) {
                stack.push(data[i]);
            } else {
                //2. 计算运算结果
                p = (int) stack.pop();
                q = (int) stack.pop();

                //3. 运算后将运算结果进栈
                if ("+".equals(data[i])) {
                    res = q + p;
                } else if ("-".equals(data[i])) {
                    res = q - p;
                } else if ("*".equals(data[i])) {
                    res = q * p;
                } else if ("/".equals(data[i])) {
                    res = q / p;
                } else {
                    System.out.println("输入有误");
                }

                //4. 将运算结果进栈
                stack.push(res);
            }
        }

        //5. 获取最终结果
        int calc = (int) stack.pop();

        System.out.println("逆波兰表达式【9 3 1 - 3 * + 10 2 / +】的运算结果是：" + calc); // 正确结果是20
    }
}

```

-------
**队列（Queue）：一种只允许在一端进行插入操作，另一端进行删除操作的线性表。**队列是一种先进先出（FLFO）的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。

![队列](/img/Queue/Queue-1.png)

### 总结：
顺序存储结构的栈与队列都是特殊的线性表.
Java中栈与堆：
- Java应用程序在执行时，栈中数据会保存以下内容：基本数据类型的值，引用变量的值（堆区对象的引用）
- 栈中的数据和堆中的数据销毁并不是同步的。方法一旦结束，栈中的局部变量（方法栈或线程栈）立即销毁，但是堆中对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁，而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁【垃圾回收机制自动判断对象是否可以被销毁，可以调用System.gc()，但是不确保一定能销毁对象】。
- 每个方法执行的时候都会建立自己的栈区，在方法中定义的局部变量（参数，方法中定义的变量）都在栈区中存放当方法结束时这些局部变量也就结束了，但是堆内存中的对象不会随着方法的结束而销毁，而是判断还有没有引用变量引用到这个对象如果有的话就是说这个对象可达所以不会轻易的被GC回收。