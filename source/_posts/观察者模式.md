---
title: 观察者模式
date: 2017-07-07 22:02:56
tags:
- 设计模式
---
观察者模式有时又被称为发布/订阅模式或者从属模式。一个目标对象管理所有依赖于它的观察者对象，
并且在自身状态改变时主动发出通知。通知通常通过调用观察者所提供的方法来实现。

# 1、观察者模式的结构
- 抽象被观察者(Subject)：抽象主题，提供接口供观察者订阅，退订；
- 具体观察者(ConcreteSubject)：使用集合管理所有已经订阅的观察者；更新自身的方法
- 抽象观察者(Observer)：定义接口，在获得被观察者的通知时更新自己
- 具体观察者(ConcreteObserver)：抽象观察者实现

<!-- more -->

# 2、应用
假设有一台服务器需要发送消息给外围，已经订阅的客户端获得消息后需要更新自身，取消订阅就不会接收消息。
![观察者模式](/img/设计模式/观察者模式/Observer.png)


抽象被观察者


```java
package com.xiaopeng.observer;

/**
 * @author xiaopeng
 * 抽象被观察者接口
 */
public interface Observerable {

    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObserver();
}

```

具体被观察者

```java
package com.xiaopeng.observer;

import java.util.ArrayList;
import java.util.List;

/**
 * @author xiaopeng
 */
public class WeChatServer implements Observerable{

    public static List<Observer> list;  //该list保存所有注册的观察者，用来通知
    private String message;

    public WeChatServer() {
        list = new ArrayList<Observer>();
    }

    @Override
    public void registerObserver(Observer o) {
        list.add(o);
    }

    @Override
    public void removeObserver(Observer o) {

        if(!list.isEmpty())
            list.remove(o);
    }

    @Override
    public void notifyObserver() {

        for(int i = 0;i<list.size();i++){
            list.get(i).update(message);  //观察者调用自身方法
        }
    }

    public void setInfomation(String _message){
        this.message = _message;
        System.out.println("WeChatServer 更新消息：" + _message);

        //通知
        notifyObserver();
    }
}

```

抽象观察者

```java
package com.xiaopeng.observer;

/**
 * @author xiaopeng
 * 当被观察者发生变化时，观察者会自动调用update方法
 */
public interface Observer {

    public void update(String message);
}

```

具体观察者

```java
package com.xiaopeng.observer;

/**
 * @author xiaopeng
 */
public class User implements Observer{

    private String name;
    private String message;

    public User(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        this.message = message;
        read();
    }

    private void read() {
        System.out.println(name + " get : " + message);
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

测试类

```java
package com.xiaopeng.observer;

import org.junit.Test;

public class App {

    @Test
    public void test_E001(){

        WeChatServer server = new WeChatServer();
        Observer o1 = new User("user1");
        Observer o2 = new User("user2");
        Observer o3 = new User("user3");

        server.registerObserver(o1);
        server.registerObserver(o2);
        server.registerObserver(o3);

        System.out.println("-------------已经注册的观察者-------------");
        for(int i=0 ;i < WeChatServer.list.size();i++){
            System.out.println(WeChatServer.list.get(i));
        }

        server.setInfomation("l love programming！");
    }
}

```
输出

```
-------------已经注册的观察者-------------
User{name='user1'}
User{name='user2'}
User{name='user3'}
WeChatServer 更新消息：l love programming！
user1 get : l love programming！
user2 get : l love programming！
user3 get : l love programming！
```

# 3、jdk中的使用
**jdk中java.util.Observer以及java.util.Observable，对观察者模式进行了实现。**

# 4、总结
可以发现：被观察者发出一次消息，所有注册的观察者都会更新自身的状态。

- 优点
1. 观察者与被观察者之间属于轻度的关联关系，并且都是抽象耦合的易拓展
2. 观察者模式是一种常用的触发机制，它形成一条触发链，依次对各个观察者的方法进行处理。但同时，这也算是观察者模式一个缺点，由于是链式触发，当观察者比较多的时候（**一个对象既是观察者也是被观察者**），性能问题是比较令人担忧的。
并且，在链式结构中，比较容易出现循环引用的错误，造成系统假死。

