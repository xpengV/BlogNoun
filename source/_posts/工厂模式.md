---
title: 工厂模式
date: 2017-07-02 21:26:28
tags:
- 设计模式
---
在java语言中，实例化对象的方式大多使用new关键字，但是在某些情况下使用new关键字来实例化对象并不是最好的选择。
比如：某个类型的创建需要一系列初始值的计算工作，或者需要首先创建其他的辅助对象。那么类型的创建就不是单一的操作，而是一系列操作！客户端并不关心对象其内部的复杂运作，只是需要一个简单入口可以获得自己想要的实例。

## 1、工厂模式
为创建对象提供过渡接口，以便将创建对象的内部调用屏蔽起来，达到提高灵活性的目的。工厂模式可以分为三类：
1. 简单工厂模式[simple factory]
2. 工厂方法模式[factory method]
3. 抽象工厂模式[abstract factory]

### 1.1、三种方式的区别

- simple factory / factory method

一个抽象产品类--->多个具体产品类
一个抽象工厂类--->多个具体工厂类
**每个具体工厂只能创建一个具体的产品（一对一关系）**
- abstract factory

多个抽象产品类--->每种抽象产品对应多个具体产品
一个抽象工厂类--->多个具体工厂类
**每个具体工厂可以创建多个具体的产品（一对多关系）**

## 2、简单工厂
![简单工厂](/img/设计模式/工厂模式/简单工厂模式.png)

生产thinkpad的内部过程必然是复杂的，但是经过工厂模式后都被屏蔽了起来。**工厂是核心，应该包含一定的业务判断和逻辑用来选择进行创建的产品。**
```java
public abstract class Computer {

    public Computer(){};
}

public class ThinkPad_E450 extends Computer {

    public ThinkPad_E450(){
        System.out.println("生产ThinkPad_E450");
    }

}

public class ThinkPad_E460 extends Computer {

    public ThinkPad_E460(){
        System.out.println("生产ThinkPad_E460");
    }

}

public class SimpleFactory {

    public Computer createComputer(int type) {
        switch (type) {
            case 450:
                return new ThinkPad_E450();
            case 460:
                return new ThinkPad_E460();
            default:
                break;
        }
        return null;
    }
}

public class App {
    public static void main(String[] args){
        SimpleFactory factory = new SimpleFactory();
        factory.createComputer(450);
    }
}
```
分析代码：对于产品而言，如果需要新增产品那么创建Computer的子类即可，但是对于工厂则要修改业务逻辑来适配新产品的创建，这显然违背好的设计原则。在实际的生产中产品的形态可能是一种树状结构，就更加复杂了。
**我们将工厂类也定义成接口，每增加一种产品类型就增加一个工厂的实现来适配对应的产品创建**，这样工厂的设计就可以扩展而不是去修改原来的代码！

## 3、工厂方法模式
针对每种产品适配一个工厂，UML如下。代码见[My Github - 设计模式](https://github.com/xpengV/DesignPattern)
![工厂方法模式](/img/设计模式/工厂模式/工厂方法模式.png)
工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口，但使得对象的数量成倍增长。
当产品种类非常多时，会出现大量的与之对应的工厂对象。

## 4、抽象工厂模式
抽象工厂是工厂方法模式的升级版，它用来创建一组相互依赖的对象。比如每个抽象产品角色都包含两个具体产品，并且它们之间是相互依赖的。在调用工厂暴露的方法创建产品时，会同时创建相互依赖的对象来构建一个完整的产品。而不是单个创建然后组装。[详见：抽象工厂模式](https://blog.csdn.net/jason0539/article/details/44976775)